# 魔鬼游戏战斗纵向切片框架及细节

## 目录
### 跑前须知 -- requirments
### 自走棋战斗逻辑
### 战斗框架组成部分
### 组成部分详情

### 跑前须知
建议python版本：3.11.3
  python版本需兼容type indication
1. 安装python 3.11.3
2. 在终端中跑
```
python -m venv /path/to/new/virtual/environment
```
  创建虚拟环境
3. 在终端跑
```
cd path/to/folder
python3 battle.py
```

### 自走棋战斗逻辑
自走棋顾名思义，是以棋子自身根据当前条件自发进行移动，攻击，技能施放 等动作。
在对战前，玩家可以对所有棋子进行操作，如购买，升级，放置棋子到棋盘上，撤回棋子到备战区，布阵等。而一旦战斗开始，玩家将不能操作，战斗完全靠棋子自动判断行动。这也就形成了自走棋基本的判断逻辑：当回合将要发生的所有情况在棋子放置好之后就已经确定了，并且可以计算出来。所展示给玩家的内容完全是预先计算的结果。
举个例子：在第一回合的时候，给予玩家的费用只够玩家购买一个棋子。每回合一定的十五秒倒计时开始：玩家可以选择上场这个棋子（比如他抽到了<蚂蚁>）也可以选择不上场这个棋子。玩家选择将“蚂蚁”放入场上。在15秒倒计时结束之后战斗自动开始，显示了对方的棋子，比如说对方棋子是一个<小丑鱼>。这个时候玩家将不能再做任何操作。蚂蚁和小丑鱼将会根据棋子已有的算法自动移动，攻击，和施法直至一方棋子完全死亡，回合就会结束。

因为自走棋是完全自发的攻击，移动和施法的。所以我们需要时间做驱动轴。

战斗的过程本质上是一个时间递增的过程。所以战斗的主体是一个循环，在这个循环内，有一个最小的时间单位，我们可以叫他 timestamp（时间章）。在每个timestamp 到来的时候我们轮流对棋子进行判定，然后棋子会根据算法自主行动。

在这个游戏中，我们的timestamp 是0.05秒，即0.05秒时游戏判定的最小单位，也是所有计数器的最大公约数。为了保证程序的运行，代码中的时间都是以整数表示，只有在终端打印的时候才做除以100 的操作，以达到显示目的。

在对单个棋子进行判定的时候，我们依次对棋子的 死亡、位置、状态、技能、攻击、移动 进行判定。后面的详情会详细介绍每种判定是什么意思。

### 战斗框架组成部分明细
为了实现上述的种种判定，我们需要对我们在游戏中看到的物件进行抽象建模，这些模块大概分为四大类

1. 战斗主体模块
2. 棋子模块
3. 棋子技能模块
4. 棋子状态模块
   
#### 1. 战斗主体模块 [battle.py](https://github.com/hz2001/devil_game_battle_model/blob/master/battle.py)
主要作用：这个模块集合了其余三大模块，其主要作用是模拟玩家的游玩环境，并且进行战斗的循环（对于棋子的判定）。在这个部分里，玩家可以选择上场的棋子，它们的数量，以及摆放的位置。

主要方法：

addRedTeam(teamList)   
addBlueTeam(teamList)   
这两个方法的作用是将棋子list导入在棋盘中，输入为 一个棋子list, list里面必须是 chessInterface 及其子类。填入棋子的时候需要用 
```
[ant(position=[0,0]), ant(position=[0,1]),ant(position=[0,2]),ant(position=[0,2]),ant(position=[0,2])]
```
这种格式来填写。   

board_print()    
这个方法的作用是打印当前的棋盘，不需要任何输入值。

battle_with_skills()
这个方法承载了主要战斗循环，以及判定逻辑，在准备工作做完之后就可以调用这个方法开始战斗。

#### 2. 棋子模块 [chessInterface.py](https://github.com/hz2001/devil_game_battle_model/blob/master/chessInterface.py)

棋子是自走棋中最重要的组成部分，也是最复杂的部分。在一局自走棋游戏中，自走棋棋子需要自动完成所有其需要做的事情。这一部分将会介绍关于棋子的重要属性和重要方法。

1. 每个棋子都有固定的属性，如攻击力，攻击间隔，护甲，血量等。在chessInterface.py这个文件的[52-75](https://github.com/hz2001/devil_game_battle_model/blob/3b7433f48f07513b8e37845e85618e4a6c396e85/chessInterface.py#L52)行中有详细的介绍。
2. 棋子相等的判定：每个棋子都有一个种类id和一个唯一id，比如 <老虎>这个棋子的种类id是24，我每创建一个老虎棋子，种类id都不会变，而唯一id会加1。我们使用唯一id来对棋子的相等做判定。
3. 在每个棋子的判定阶段，can_cast() 和 can_attack() 和 can_move()方法可以用来判定当前棋子能否做施法、攻击以及移动等操作。
4. 与其对应的，do_attack() move_to()这两个方法是棋子公用的攻击和移动方法，在需要这两种操作的时候，只需要调用这两种方法就可以了。需要注意的是，当我们开发一个棋子的时候，我们需要配套得实现一个cast()方法，这个方法用来施放技能，这是因为每个棋子施放技能的条件和技能效果都有所不同，需要分别开发。
5. deal_damage_to() 是每个棋子对其他棋子造成伤害的方法，并且所有的攻击、技能以及状态伤害都需要调用这个方法（这点很重要）。这个方法只会让棋子掉血，而不计算初始伤害以及判定伤害时间。在调用这个方法之前需要提前对目标和伤害进行判定。这个方法还会判定目标的状态，如果符合特殊情况会重新计算伤害数值（比如被伤害者是犀牛，而犀牛的技能是所有虫对其造成的伤害降低，那么这个方法会对目标进行判定是不是犀牛）。
6. calculate_attack_damage() 会根据目标护甲计算攻击伤害。
7. get_enemy() 是棋子的核心寻路算法，这个方法会返回棋子最近敌人，距离和向哪个方向移动才可以找到目标棋子。在棋子每次判定的时候，这个方法都会根据当前棋盘给出一个最佳移动方向，棋子会根据这个方向进行移动，移动为一个持续0.3秒的状态，在这个状态中棋子不能做其他的动作。在棋子找到下一次移动的位置之后，就会在棋盘上自动显示为已经占据了将要移动到的位置，从而不会和其他棋子的移动相互干扰。     

其他方法没有上述这些这么重要，但是也会在实现某些棋子技能的时候发挥一定作用。

#### 3. 技能模块 skillInterface.py

目前为止，一个棋子都匹配了一个技能，棋子除了自己的独特属性之外，还有一个 cast() 方法需要被开发，这个方法需要根据技能效果需要进行实现。

#### 4. 状态模块 statusInterface.py

状态是指当前棋子被附加的属性，这个属性不同于固定的属性，是可以被移除的。一般来说状态都有时间限制，无论是buff还是debuff，时间到了之后都会失去作用。每一个状态都会对状态所有者的某些属性进行修改，状态结束则被修改的属性也会回到原本值。
每一个状态都有一个 activate()方法，这个方法被 chessInterface里面的activate_status()调用。


